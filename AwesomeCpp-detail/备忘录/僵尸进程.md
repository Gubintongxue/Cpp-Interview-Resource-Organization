两种情况造成僵尸进程：1.子进程退出后，父进程没有读取子进程的退出信息前，内核不会立即释放该进程的进程表表项；2.父进程退出后，子进程退出前，子进程成为孤儿进程被init进程接管，此时子进程是僵尸进程

解决1的方法：父进程调用wait或者waitpid配合SIGCHILD信号读取子进程退出信息；wait是阻塞进程，直到该进程的某个子进程运行退出，返回运行结束的子进程的PID,并将退出信息存在stat_loc参数指向的内存中,wait的
阻塞特性是不理想的。waitpid解决了这个阻塞问题，在父进程中捕获监听SIGCHILD信号，信号处理函数中调用waitpid读取该退出的进程的退出信息(《Linux高性能编程》p240)

解决2的方法：在子进程中调用[prctl(PR_SET_PDEATHSIG,SIGKILL)](https://zhuanlan.zhihu.com/p/56833833?utm_source=wechat_session&utm_medium=social&utm_oi=752170274572500992&utm_campaign=shareopn)，在父进程退出时，子进程将会收到SIGKILL信号，而进程收到该信号的默认动作则是退出。因而最后不会看到它成为孤儿进程，被其他进程所收养。需要注意的是，该函数并非所有系统都支持
